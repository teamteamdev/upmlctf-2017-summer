# Not simple: Write-up

Откроем картинку. То, что вы увидели, называется мем. Судя по условию таска,
получатель файла явно не ждал получить картинку, и он считает, что файл
должен открываться как-то по-другому. Можно открыть этот файл любым
HEX-редактором или программой Stegsolve и увидеть после данных картинки ещё
какие-то байты данных.

Известным фактом является то, что в файле JPEG всё, что идет после окончания
изображения, не влияет на отображение картинки в программах просмотра
изображений, и, следовательно, там можно спрятать данные. Так и было сделано
в этом таске.

## Вариант 1

Байты, начиная с 0x41dd (16861), являются байтами посторонних данных. Сохраним
их в отдельный файл. Это делается HEX-редактором или простой программой на Python:

```python
START = 16861
data = open("pic.jpg", "rb").read()[START:]
with open("part", "wb") as f:
    f.write(data)
```

Получаем [бинарный файл с данными](part).
Можно запустить Linux-утилиту `file`, чтобы определить тип файла:

```
$ file part
part: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=fbabe210a1f58c9d3dd4ef3ec5a0eb7065832700, not stripped
```

Предположим, что у нас Linux и 64-битная операционная система, запустим этот
бинарный файл.

```
$ chmod +x part
$ ./part
Enter check number:
```

Вообще, перебор чисел тоже бы не помог (это понятно, если взглянуть на
[исходный код программы](source.cpp)).

Остался последний способ — запустим утилиту `strings`. Она выведет много строк,
среди которых и найдется флаг к заданию.

## Вариант 2

Можно было всё это не делать, и сразу в HEX-редакторе найти искомую строку.
Однако, автор таска рассчитывал на то, что вы этого не заметите и будете
делать действия из варианта 1.

Флаг: **uctf_boring_task**
